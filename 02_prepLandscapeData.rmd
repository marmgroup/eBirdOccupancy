---
editor_options: 
  chunk_output_type: console
---

# Prepare landscape data

## Prepare libraries

```{r load_libs2, eval=FALSE, message=FALSE, warning=FALSE}

# load libs
library(raster)
library(stringi)
library(glue)
library(gdalUtils)
library(purrr)

# prep mode function to aggregate
funcMode <- function(x, na.rm = T) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

# a basic test
assertthat::assert_that(funcMode(c(2,2,2,2,3,3,3,4)) == as.character(2), 
                        msg = "problem in the mode function") # works
```

## Prepare initial data

### Prepare spatial extent

```{r load_hills, eval=FALSE, message=FALSE, warning=FALSE}
# load hills
library(sf)
hills <- st_read("data/spatial/hillsShapefile/Nil_Ana_Pal.shp")
```


### Prepare terrain rasters

```{r terrain_raster, eval=FALSE, message=FALSE, warning=FALSE}
# load elevation and crop to hills size, then mask by hills
alt <- raster("data/spatial/Elevation/alt")
alt.hills <- crop(alt, as(hills, "Spatial"))
rm(alt); gc()

# get slope and aspect
slopeData <- terrain(x = alt.hills, opt = c("slope", "aspect"))
elevData <- raster::stack(alt.hills, slopeData)
rm(alt.hills); gc()
```

### Prepare EVI rasters

```{r evi_raster, eval=FALSE, message=FALSE, warning=FALSE}
# load evi layers
evi <- raster::stack("data/spatial/EVI/MOD13Q1_EVI_AllYears.tif")[[c(1,7,10)]]

# reproject to elevdata
evi <- projectRaster(evi, elevData, res(elevData))
```

### Prepare CHELSA rasters

```{r chelsa_rasters, eval=FALSE, message=FALSE, warning=FALSE}
# list chelsa files
chelsaFiles <- list.files("data/chelsa/", full.names = TRUE, pattern = "crop.tif")

# gather chelsa rasters
chelsaData <- purrr::map(chelsaFiles, function(chr){
  a <- raster(chr)
  crs(a) <- crs(evi)
  return(a)
})

# stack chelsa data
chelsaData <- raster::stack(chelsaData)

# project to elevation
chelsaData <- projectRaster(chelsaData, elevData, res(elevData))
```

### Stack prepared rasters

```{r stack_rasters, eval=FALSE, message=FALSE, warning=FALSE}
# stack rasters for efficient reprojection later
env_data <- stack(elevData, evi, chelsaData)
```

### Prepare landcover

```{r landcover_raster, eval=FALSE, message=FALSE, warning=FALSE, message=FALSE}
# read in landcover raster location
landcover <- "data/landUseClassification/ClassifiedImage_31stAug_UTM34N_Ghats.tif"
# get extent
e = bbox(raster(landcover))

# use gdalutils gdalwarp for resampling transform
# to 1km from 10m
gdalwarp(srcfile = landcover, 
         dstfile = "data/landUseClassification/lc_01km.tif", 
         tr=c(1000,1000), r='mode', te=c(e))
```

## Resample rasters

### Read landcover as list

Here, we read in the 1km, 10km, and 25km resampled landcover rasters as a list.

```{r read_resamp_lc, eval=FALSE, message=FALSE, warning=FALSE}

# list the files and map a raster read over them
lc_files <- list.files("data/landUseClassification/", 
                       pattern = "01km.tif", full.names = TRUE)
lc_data <- map(lc_files, raster)
```

### Reproject environmental data to landcover

```{r resample_env_data, eval=FALSE, message=FALSE, warning=FALSE}

# resample to the corresponding landcover data
env_data_resamp <- map(lc_data, function(rs){
  projectRaster(from = env_data, to = rs, crs = crs(rs), res = res(rs))
})

# export as raster stack
land_stacks <- map2(env_data_resamp, lc_data, function(a, b){
  land_stack = stack(a, b)})

# get names
land_names <- glue('data/spatial/landscape_resamp{c("01")}km.tif')

# write to file
map2(land_stacks, land_names, function(x,y){
  writeRaster(x, filename = as.character(y), overwrite=TRUE)
})
```

